<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Kana Coach</title>

  <!-- Favicon: Japanese flag (inline SVG data URI) -->
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg%20xmlns%3D%27http%3A//www.w3.org/2000/svg%27%20viewBox%3D%270%200%2032%2032%27%3E%3Crect%20width%3D%2732%27%20height%3D%2732%27%20fill%3D%27%23ffffff%27/%3E%3Ccircle%20cx%3D%2716%27%20cy%3D%2716%27%20r%3D%279%27%20fill%3D%27%23bc002d%27/%3E%3C/svg%3E">
  <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg%20xmlns%3D%27http%3A//www.w3.org/2000/svg%27%20viewBox%3D%270%200%20180%20180%27%3E%3Crect%20width%3D%27180%27%20height%3D%27180%27%20rx%3D%2736%27%20fill%3D%27%23ffffff%27/%3E%3Ccircle%20cx%3D%2790%27%20cy%3D%2790%27%20r%3D%2752%27%20fill%3D%27%23bc002d%27/%3E%3C/svg%3E">

  <meta name="theme-color" content="#0a0c12" media="(prefers-color-scheme: dark)">
  <meta name="theme-color" content="#faf7f2" media="(prefers-color-scheme: light)">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-mobile-web-app-title" content="Kana Coach">

  <style>
    :root{
      --bg:#0a0c12;
      --paper: rgba(18,20,28,.92);
      --paper2: rgba(18,20,28,.82);
      --card: rgba(18,20,28,.86);

      --text:#eef1fb;
      --muted:#aeb6c8;
      --border: rgba(255,255,255,.14);
      --shadow: rgba(0,0,0,.42);

      --indigo:#6f84ff;
      --vermilion:#ff3b4f;
      --sakura:#ffb7c5;

      --good:#63e7b0;
      --almost:#ffd27a;
      --bad:#ff6b7a;

      --focus: rgba(111,132,255,.22);
      --input: rgba(0,0,0,.26);
      --overlay: rgba(0,0,0,.62);

      --radius:20px;
      --btnRadius:14px;
      --tap: 44px;
    }

    @media (prefers-color-scheme: light){
      :root{
        --bg:#faf7f2;
        --paper: rgba(255,255,255,.96);
        --paper2: rgba(255,255,255,.90);
        --card: rgba(255,255,255,.92);

        --text:#111827;
        --muted:#5b6475;
        --border: rgba(0,0,0,.12);
        --shadow: rgba(17,24,39,.14);

        --indigo:#2f55ff;
        --vermilion:#e60026;
        --sakura:#ff89a2;

        --good:#0f9d58;
        --almost:#b06000;
        --bad:#d93025;

        --focus: rgba(47,85,255,.18);
        --input: rgba(255,255,255,.96);
        --overlay: rgba(0,0,0,.30);
      }
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color:var(--text);
      background:
        radial-gradient(900px 700px at 20% 12%, color-mix(in oklab, var(--indigo) 16%, transparent), transparent 58%),
        radial-gradient(700px 600px at 85% 18%, color-mix(in oklab, var(--sakura) 14%, transparent), transparent 62%),
        radial-gradient(900px 800px at 50% 110%, color-mix(in oklab, var(--vermilion) 10%, transparent), transparent 62%),
        var(--bg);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    .wrap{
      max-width: 980px;
      margin: 0 auto;
      padding: calc(env(safe-area-inset-top) + 14px) 14px calc(env(safe-area-inset-bottom) + 18px);
    }

    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
      margin-bottom:12px;
    }

    /* Simple text title (replaces logo) */
    .brand{
      font-size: 20px;
      font-weight: 750;
      letter-spacing: .3px;
      color: var(--text);
      user-select: none;
      line-height: 1;
    }

    button{
      border:1px solid var(--border);
      background: color-mix(in oklab, var(--bg) 55%, var(--card));
      color:var(--text);
      border-radius: var(--btnRadius);
      padding: 9px 11px;
      cursor:pointer;
      font-size:14px;
      min-height: 40px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      line-height: 1;
    }
    button.primary{
      background: linear-gradient(180deg,
        color-mix(in oklab, var(--indigo) 38%, var(--card)),
        color-mix(in oklab, var(--indigo) 18%, var(--card))
      );
      border-color: color-mix(in oklab, var(--indigo) 45%, var(--border));
    }
    button.ghost{
      background: color-mix(in oklab, var(--bg) 68%, var(--card));
    }
    button.icon{
      width: 44px;
      height: 44px;
      padding: 0;
      border-radius: 14px;
      min-height: 44px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
    }
    /* SVG ensures true centering */
    .icon svg{
      width: 22px;
      height: 22px;
      display:block;
    }
    .iconGlyph{
      font-size: 20px;
      line-height: 1;
      display:block;
      opacity: .95;
    }
    button:disabled{opacity:.5;cursor:not-allowed}

    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}

    .card{
      border:1px solid var(--border);
      border-radius: var(--radius);
      background: linear-gradient(180deg, var(--card), var(--paper2));
      box-shadow: 0 14px 30px var(--shadow);
      padding: 16px;
      position: relative;
      overflow:hidden;
    }
    .card::before{
      content:"";
      position:absolute;
      inset:-2px;
      background: radial-gradient(600px 220px at 20% 0%,
        color-mix(in oklab, var(--sakura) 16%, transparent),
        transparent 60%
      );
      opacity:.65;
      pointer-events:none;
    }
    .card > *{position:relative}

    .stack{
      display:grid;
      gap:12px;
    }

    .promptCard{
      text-align:center;
      padding-top: 18px;
      padding-bottom: 14px;
    }

    .bigPrompt{
      font-family: ui-rounded, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      font-size: clamp(46px, 9vw, 76px);
      line-height:1.05;
      margin: 6px 0 10px;
      letter-spacing:.5px;
      text-shadow: 0 10px 30px color-mix(in oklab, var(--indigo) 10%, transparent);
    }

    .promptMeta{
      display:flex;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
      color:var(--muted);
      font-size:12px;
      border-top:1px solid var(--border);
      padding-top:10px;
      margin-top:8px;
    }

    .result{
      border:1px solid var(--border);
      border-radius: var(--radius);
      background: linear-gradient(180deg, var(--paper), var(--paper2));
      box-shadow: 0 10px 25px var(--shadow);
      padding: 14px 14px;
      min-height: 124px;
    }
    .status{
      margin:0 0 10px;
      font-weight:950;
      letter-spacing:.2px;
      display:flex;
      align-items:center;
      gap:10px;
    }
    .status.good{color:var(--good)}
    .status.almost{color:var(--almost)}
    .status.bad{color:var(--bad)}

    .defBox{
      border:1px solid var(--border);
      border-radius: 16px;
      padding:12px 12px;
      background: color-mix(in oklab, var(--bg) 35%, var(--card));
      margin:10px 0 10px;
    }
    .defLabel{margin:0 0 4px;color:var(--muted);font-size:12px}
    .defText{margin:0;font-size:19px;font-weight:950;line-height:1.25}
    .mini{margin:6px 0;color:var(--muted);font-size:13px;line-height:1.45}

    /* Make the text entry section the focal point + center aligned */
    .answerCard{
      padding-top: 14px;
      border-color: color-mix(in oklab, var(--indigo) 55%, var(--border));
      box-shadow:
        0 18px 44px var(--shadow),
        0 0 0 1px color-mix(in oklab, var(--indigo) 12%, transparent);
      text-align:center;
    }
    .answerCard::before{
      content:"";
      position:absolute;
      inset:-2px;
      background:
        radial-gradient(560px 260px at 35% 20%,
          color-mix(in oklab, var(--indigo) 26%, transparent),
          transparent 62%
        ),
        radial-gradient(520px 260px at 80% 60%,
          color-mix(in oklab, var(--sakura) 16%, transparent),
          transparent 66%
        );
      opacity:.85;
      pointer-events:none;
    }
    .answerInner{
      max-width: 560px;
      margin: 0 auto;
    }

    input[type="text"]{
      width:100%;
      border:1px solid var(--border);
      background: var(--input);
      color:var(--text);
      border-radius: 14px;
      padding: 13px 12px;
      font-size:18px;
      min-height: calc(var(--tap) + 4px);
      outline:none;
      text-align:center;
    }
    input[type="text"]:focus{
      border-color: color-mix(in oklab, var(--indigo) 70%, var(--border));
      box-shadow: 0 0 0 4px var(--focus);
    }

    .btns{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:10px;
      justify-content:center;
    }
    .btns button{
      min-height: 40px;
      padding: 9px 11px;
      border-radius: 12px;
      font-size: 13.5px;
    }

    .bottom{
      margin-top: 12px;
      display:grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap:10px;
    }
    .statCard{
      border:1px solid var(--border);
      border-radius: var(--radius);
      background: linear-gradient(180deg, var(--card), var(--paper2));
      box-shadow: 0 10px 22px var(--shadow);
      padding: 12px 12px;
      min-height: 84px;
      min-width: 0;
    }
    .statLabel{margin:0 0 2px;color:var(--muted);font-size:12px}
    .statValue{margin:0;font-size:26px;font-weight:950;letter-spacing:.2px;line-height:1.05}
    .statSub{margin:6px 0 0;color:var(--muted);font-size:12px;line-height:1.35}

    .pills{
      margin-top: 10px;
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      align-items:center;
    }
    .pill{
      font-size:12px;color:var(--muted);
      border:1px solid var(--border);
      padding:6px 10px;
      border-radius:999px;
      background: color-mix(in oklab, var(--bg) 55%, var(--card));
      white-space:nowrap;
    }

    /* Keep metrics in a single row on mobile (shrink rather than stack) */
    @media (max-width: 640px){
      .bottom{
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap:8px;
      }
      .statCard{padding:10px; min-height:76px}
      .statValue{font-size:22px}
      .statLabel{font-size:11px}
      .statSub{font-size:11px; margin-top:4px}
    }
    @media (max-width: 420px){
      .bottom{
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap:7px;
      }
      .statCard{padding:9px; min-height:72px}
      .statValue{font-size:20px}
      .statLabel{font-size:10.5px}
      .statSub{font-size:10.5px}
    }

    @media (max-width: 520px){
      .card{padding:14px}
      .bigPrompt{font-size: clamp(44px, 11vw, 64px)}
      .btns{gap:8px}
      .btns button{font-size:13px}
      .statValue{font-size:24px}
      .pill{font-size:11.5px}
      input[type="text"]{font-size:18px}
      .brand{font-size:19px}
    }

    /* Drawer */
    .drawerOverlay{
      position:fixed;
      inset:0;
      background: var(--overlay);
      opacity:0;
      pointer-events:none;
      transition: opacity .18s ease;
      z-index: 50;
    }
    .drawerOverlay.open{opacity:1;pointer-events:auto}

    .drawer{
      position:fixed;
      top:0;
      right:0;
      height:100%;
      width: min(380px, 92vw);
      background: linear-gradient(180deg, var(--paper), var(--paper2));
      border-left: 1px solid var(--border);
      box-shadow: -18px 0 40px var(--shadow);
      transform: translateX(102%);
      transition: transform .22s ease;
      z-index: 60;
      padding: calc(env(safe-area-inset-top) + 14px) 14px calc(env(safe-area-inset-bottom) + 16px);
      overflow:auto;
    }
    .drawer.open{transform: translateX(0)}
    .drawerHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom: 10px;
    }
    .drawerTitle{margin:0;font-size:14px}
    .drawerSection{
      border-top:1px solid var(--border);
      padding-top:12px;
      margin-top:12px;
    }
    .drawerSection:first-of-type{border-top:none;padding-top:0;margin-top:0}
    .drawerSection h2{margin:0 0 10px;font-size:13px}
    label{display:flex;gap:10px;align-items:center;color:var(--muted);font-size:13px;margin:8px 0}
    select{
      width:100%;
      border:1px solid var(--border);
      background: var(--input);
      color:var(--text);
      border-radius:12px;
      padding:10px 10px;
      font-size:14px;
      min-height: var(--tap);
      outline:none;
    }
    .hintBox{
      border:1px dashed var(--border);
      border-radius:14px;
      padding:10px 12px;
      background: color-mix(in oklab, var(--bg) 22%, var(--card));
      color:var(--muted);
      font-size:12px;
      line-height:1.4;
      margin-top:10px;
    }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:12px;
      border:1px solid var(--border);
      border-radius:10px;
      padding:4px 8px;
      color:var(--muted);
      background: color-mix(in oklab, var(--bg) 25%, var(--card));
      display:inline-block;
      margin:2px 6px 2px 0;
    }

    /* Tutorial / Help modal */
    .modalOverlay{
      position:fixed; inset:0;
      background: var(--overlay);
      opacity:0;
      pointer-events:none;
      transition: opacity .18s ease;
      z-index: 80;
    }
    .modalOverlay.open{opacity:1;pointer-events:auto}
    .modal{
      position:fixed;
      left:50%; top:50%;
      transform: translate(-50%,-50%) scale(.98);
      width:min(560px, 92vw);
      background: linear-gradient(180deg, var(--paper), var(--paper2));
      border:1px solid var(--border);
      border-radius: 18px;
      box-shadow: 0 20px 60px var(--shadow);
      padding: 14px;
      z-index: 90;
      opacity:0;
      pointer-events:none;
      transition: opacity .18s ease, transform .18s ease;
    }
    .modal.open{
      opacity:1;
      pointer-events:auto;
      transform: translate(-50%,-50%) scale(1);
    }
    .modal h3{margin:0 0 8px;font-size:16px}
    .modal ul{margin:10px 0 0 18px;color:var(--muted);font-size:13px;line-height:1.5}
    .modal .ctaRow{display:flex;gap:10px;justify-content:flex-end;margin-top:12px;flex-wrap:wrap}
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <!-- Simple title -->
      <div class="brand" aria-label="Kana Coach">Kana Coach</div>

      <div style="display:flex;gap:10px;align-items:center">
        <button class="icon" id="helpBtn" aria-label="Help"><span class="iconGlyph">?</span></button>

        <!-- Settings cog as SVG for true centering -->
        <button class="icon" id="menuBtn" aria-label="Open settings">
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path fill="currentColor" d="M19.14,12.94c.04-.31.06-.63.06-.94s-.02-.63-.06-.94l2.03-1.58c.18-.14.23-.4.12-.61l-1.92-3.32c-.11-.21-.36-.3-.58-.22l-2.39.96c-.5-.38-1.04-.7-1.64-.94l-.36-2.54c-.03-.23-.23-.4-.47-.4h-3.84c-.24,0-.44.17-.47.4l-.36,2.54c-.6.24-1.15.56-1.64.94l-2.39-.96c-.22-.09-.47.01-.58.22l-1.92,3.32c-.11.21-.06.47.12.61l2.03,1.58c-.04.31-.06.63-.06.94s.02.63.06.94l-2.03,1.58c-.18.14-.23.4-.12.61l1.92,3.32c.11.21.36.3.58.22l2.39-.96c.5.38,1.04.7,1.64.94l.36,2.54c.03.23.23.4.47.4h3.84c.24,0,.44-.17.47-.4l.36-2.54c.6-.24,1.15-.56,1.64-.94l2.39.96c.22.09.47-.01.58-.22l1.92-3.32c.11-.21.06-.47-.12-.61l-2.03-1.58ZM12,15.5c-1.93,0-3.5-1.57-3.5-3.5s1.57-3.5,3.5-3.5,3.5,1.57,3.5,3.5-1.57,3.5-3.5,3.5Z"/>
          </svg>
        </button>
      </div>
    </div>

    <div class="stack">
      <!-- 1) Result container (moved to top) -->
      <div class="result" id="result">
        <p class="mini">Press <b>Enter</b> to check. Press <b>Enter</b> again for next.</p>
      </div>

      <!-- 2) Prompt container -->
      <div class="card promptCard">
        <div class="bigPrompt" id="prompt">—</div>
        <div class="promptMeta">
          <div id="typeMeta">—</div>
          <div id="indexMeta">—</div>
        </div>
      </div>

      <!-- 3) Input container -->
      <div class="card answerCard">
        <div class="answerInner">
          <!-- Instructional text removed (placeholder now covers it) -->
          <input id="answer" type="text" placeholder="Type romaji…" autocomplete="off" spellcheck="false" />
          <div class="btns">
            <button class="primary" id="checkBtn">Check</button>
            <button class="ghost" id="revealBtn">Reveal</button>
            <button id="nextBtn">Next</button>
          </div>
        </div>
      </div>
    </div>

    <div class="bottom">
      <div class="statCard">
        <p class="statLabel">Streak</p>
        <p class="statValue" id="streakValue">0</p>
        <p class="statSub" id="modeTiny">Mode: Normal</p>
      </div>
      <div class="statCard">
        <p class="statLabel">Accuracy</p>
        <p class="statValue" id="accValue">—</p>
        <p class="statSub" id="seenTiny">0 attempts</p>
      </div>
      <div class="statCard">
        <p class="statLabel">Trouble kana</p>
        <p class="statValue" id="troubleValue">0</p>
        <p class="statSub">characters flagged</p>
      </div>
    </div>

    <div class="pills">
      <span class="pill" id="poolPill">Practice: —</span>
      <span class="pill" id="scriptPill">Script: —</span>
      <span class="pill" id="difficultyPill">Level: —</span>
    </div>
  </div>

  <!-- Drawer -->
  <div class="drawerOverlay" id="drawerOverlay"></div>
  <aside class="drawer" id="drawer" aria-label="Settings">
    <div class="drawerHeader">
      <h2 class="drawerTitle">Settings</h2>
      <button class="icon" id="closeDrawerBtn" aria-label="Close settings">
        <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
          <path fill="currentColor" d="M18.3 5.71a1 1 0 0 0-1.41 0L12 10.59 7.11 5.7A1 1 0 0 0 5.7 7.11L10.59 12l-4.89 4.89a1 1 0 1 0 1.41 1.41L12 13.41l4.89 4.89a1 1 0 0 0 1.41-1.41L13.41 12l4.89-4.89a1 1 0 0 0 0-1.4z"/>
        </svg>
      </button>
    </div>

    <div class="drawerSection">
      <h2>Practice mode</h2>
      <label for="modeSelect" style="display:block;margin:8px 0 6px">Mode</label>
      <select id="modeSelect">
        <option value="normal" selected>Normal (mix of characters/words/sentences)</option>
        <option value="trouble">Trouble kana (characters you miss most)</option>
        <option value="recent">Recent trouble kana (quick redo)</option>
      </select>

      <div class="hintBox" id="modeHint">
        Trouble kana is calculated across all words/sentences too — the same character missed in different contexts is counted together.
      </div>

      <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:12px">
        <button id="resetSessionBtn">Reset session stats</button>
        <button id="resetHistoryBtn">Reset learning history</button>
      </div>
    </div>

    <div class="drawerSection">
      <h2>What to practise</h2>
      <label><input type="checkbox" id="mixChars" checked /> Include characters</label>
      <label><input type="checkbox" id="mixWords" checked /> Include words (kana-only)</label>
      <label><input type="checkbox" id="mixSentences" checked /> Include short sentences (kana-only)</label>

      <label><input type="checkbox" id="allowLenient" checked /> Lenient checking (common romanisation variants)</label>
      <label><input type="checkbox" id="allowAlmost" checked /> Mark close-but-not-standard as “Almost”</label>

      <label for="scriptSelect" style="display:block;margin:12px 0 6px">Script</label>
      <select id="scriptSelect">
        <option value="both" selected>Hiragana + Katakana</option>
        <option value="hira">Hiragana only</option>
        <option value="kata">Katakana only</option>
      </select>

      <label for="difficultySelect" style="display:block;margin:12px 0 6px">Level</label>
      <select id="difficultySelect">
        <option value="easy">Easy</option>
        <option value="standard" selected>Standard</option>
        <option value="spicy">Spicy</option>
      </select>

      <div class="hintBox">
        Keyboard: <span class="kbd">Enter</span> check/next • <span class="kbd">Shift</span>+<span class="kbd">Enter</span> reveal • <span class="kbd">Esc</span> next
      </div>
    </div>
  </aside>

  <!-- Tutorial / Help modal -->
  <div class="modalOverlay" id="helpOverlay"></div>
  <div class="modal" id="helpModal" role="dialog" aria-modal="true" aria-label="Welcome">
    <div style="display:flex;align-items:center;justify-content:space-between;gap:10px">
      <h3 style="margin:0">Welcome to Kana Coach</h3>
      <button class="icon" id="closeHelpBtn" aria-label="Close help">
        <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
          <path fill="currentColor" d="M18.3 5.71a1 1 0 0 0-1.41 0L12 10.59 7.11 5.7A1 1 0 0 0 5.7 7.11L10.59 12l-4.89 4.89a1 1 0 1 0 1.41 1.41L12 13.41l4.89 4.89a1 1 0 0 0 1.41-1.41L13.41 12l4.89-4.89a1 0 0 0 0-1.4z"/>
        </svg>
      </button>
    </div>

    <p class="mini" style="margin-top:10px">
      You’ll see kana (no kanji). Type the <span class="mono">romaji</span> and press <span class="kbd">Enter</span>.
      Press <span class="kbd">Enter</span> again to move on.
    </p>

    <ul>
      <li><b>Spaces don’t matter</b> (<span class="mono">watashi wa</span> = <span class="mono">watashiwa</span>).</li>
      <li><b>Almost</b> appears for common “close” spellings (e.g. <span class="mono">cya</span> for <span class="mono">cha</span>, or <span class="mono">ha</span> when <span class="mono">は</span> is the particle <span class="mono">wa</span>).</li>
      <li><b>wo / o</b> are both accepted when <span class="mono">を</span> is used as the object particle (standard is usually <span class="mono">o</span>).</li>
      <li><b>Trouble kana</b> tracks characters you miss most — even when they appear inside different words/sentences.</li>
      <li>Your progress is saved <b>locally on this device/browser</b>.</li>
    </ul>

    <div class="ctaRow">
      <button id="dontShowAgainBtn">Got it</button>
    </div>
  </div>

<script>
(() => {
  const LS_KEY_UNIT_STATS = "kanaCoach.unitStats.v1";
  const LS_KEY_RECENT_UNITS = "kanaCoach.recentUnits.v1";
  const LS_KEY_TUTORIAL = "kanaCoach.tutorialSeen.v1";

  const clean = (s) => (s ?? "")
    .toLowerCase()
    .trim()
    .replace(/[’']/g, "")
    .replace(/[-_]/g, " ")
    .replace(/\s+/g, " ");

  const stripSpaces = (s) => s.replace(/\s+/g, "");

  const KANA_MAP = new Map([
    ["あ","a"],["い","i"],["う","u"],["え","e"],["お","o"],
    ["か","ka"],["き","ki"],["く","ku"],["け","ke"],["こ","ko"],
    ["さ","sa"],["し","shi"],["す","su"],["せ","se"],["そ","so"],
    ["た","ta"],["ち","chi"],["つ","tsu"],["て","te"],["と","to"],
    ["な","na"],["に","ni"],["ぬ","nu"],["ね","ne"],["の","no"],
    ["は","ha"],["ひ","hi"],["ふ","fu"],["へ","he"],["ほ","ho"],
    ["ま","ma"],["み","mi"],["む","mu"],["め","me"],["も","mo"],
    ["や","ya"],["ゆ","yu"],["よ","yo"],
    ["ら","ra"],["り","ri"],["る","ru"],["れ","re"],["ろ","ro"],
    ["わ","wa"],["ゐ","wi"],["ゑ","we"],["を","o"],
    ["ん","n"],
    ["が","ga"],["ぎ","gi"],["ぐ","gu"],["げ","ge"],["ご","go"],
    ["ざ","za"],["じ","ji"],["ず","zu"],["ぜ","ze"],["ぞ","zo"],
    ["だ","da"],["ぢ","ji"],["づ","zu"],["で","de"],["ど","do"],
    ["ば","ba"],["び","bi"],["ぶ","bu"],["べ","be"],["ぼ","bo"],
    ["ぱ","pa"],["ぴ","pi"],["ぷ","pu"],["ぺ","pe"],["ぽ","po"],
    ["ぁ","a"],["ぃ","i"],["ぅ","u"],["ぇ","e"],["ぉ","o"],
    ["ゃ","ya"],["ゅ","yu"],["ょ","yo"],
    ["っ","(sokuon)"],["ゎ","wa"],["ゔ","vu"],
    ["きゃ","kya"],["きゅ","kyu"],["きょ","kyo"],
    ["ぎゃ","gya"],["ぎゅ","gyu"],["ぎょ","gyo"],
    ["しゃ","sha"],["しゅ","shu"],["しょ","sho"],
    ["じゃ","ja"],["じゅ","ju"],["じょ","jo"],
    ["ちゃ","cha"],["ちゅ","chu"],["ちょ","cho"],
    ["にゃ","nya"],["にゅ","nyu"],["にょ","nyo"],
    ["ひゃ","hya"],["ひゅ","hyu"],["ひょ","hyo"],
    ["びゃ","bya"],["びゅ","byu"],["びょ","byo"],
    ["ぴゃ","pya"],["ぴゅ","pyu"],["ぴょ","pyo"],
    ["みゃ","mya"],["みゅ","myu"],["みょ","myo"],
    ["りゃ","rya"],["りゅ","ryu"],["りょ","ryo"],
    ["てゃ","tya"],["てゅ","tyu"],["てょ","tyo"],
    ["でゃ","dya"],["でゅ","dyu"],["でょ","dyo"],
    ["ふぁ","fa"],["ふぃ","fi"],["ふぇ","fe"],["ふぉ","fo"],
    ["ゔぁ","va"],["ゔぃ","vi"],["ゔぇ","ve"],["ゔぉ","vo"],["ゔゅ","vyu"],

    ["ア","a"],["イ","i"],["ウ","u"],["エ","e"],["オ","o"],
    ["カ","ka"],["キ","ki"],["ク","ku"],["ケ","ke"],["コ","ko"],
    ["サ","sa"],["シ","shi"],["ス","su"],["セ","se"],["ソ","so"],
    ["タ","ta"],["チ","chi"],["ツ","tsu"],["テ","te"],["ト","to"],
    ["ナ","na"],["ニ","ni"],["ヌ","nu"],["ネ","ne"],["ノ","no"],
    ["ハ","ha"],["ヒ","hi"],["フ","fu"],["ヘ","he"],["ホ","ho"],
    ["マ","ma"],["ミ","mi"],["ム","mu"],["メ","me"],["モ","mo"],
    ["ヤ","ya"],["ユ","yu"],["ヨ","yo"],
    ["ラ","ra"],["リ","ri"],["ル","ru"],["レ","re"],["ロ","ro"],
    ["ワ","wa"],["ヰ","wi"],["ヱ","we"],["ヲ","o"],
    ["ン","n"],
    ["ガ","ga"],["ギ","gi"],["グ","gu"],["ゲ","ge"],["ゴ","go"],
    ["ザ","za"],["ジ","ji"],["ズ","zu"],["ゼ","ze"],["ゾ","zo"],
    ["ダ","da"],["ヂ","ji"],["ヅ","zu"],["デ","de"],["ド","do"],
    ["バ","ba"],["ビ","bi"],["ブ","bu"],["ベ","be"],["ボ","bo"],
    ["パ","pa"],["ピ","pi"],["プ","pu"],["ペ","pe"],["ポ","po"],
    ["ァ","a"],["ィ","i"],["ゥ","u"],["ェ","e"],["ォ","o"],
    ["ャ","ya"],["ュ","yu"],["ョ","yo"],
    ["ッ","(sokuon)"],["ヮ","wa"],["ー","(long)"],["ヴ","vu"],
    ["キャ","kya"],["キュ","kyu"],["キョ","kyo"],
    ["ギャ","gya"],["ギュ","gyu"],["ギョ","gyo"],
    ["シャ","sha"],["シュ","shu"],["ショ","sho"],
    ["ジャ","ja"],["ジュ","ju"],["ジョ","jo"],
    ["チャ","cha"],["チュ","chu"],["チョ","cho"],
    ["ニャ","nya"],["ニュ","nyu"],["ニョ","nyo"],
    ["ヒャ","hya"],["ヒュ","hyu"],["ヒョ","hyo"],
    ["ビャ","bya"],["ビュ","byu"],["ビョ","byo"],
    ["ピャ","pya"],["ピュ","pyu"],["ピョ","pyo"],
    ["ミャ","mya"],["ミュ","myu"],["ミョ","myo"],
    ["リャ","rya"],["リュ","ryu"],["リョ","ryo"],
    ["ファ","fa"],["フィ","fi"],["フェ","fe"],["フォ","fo"],
    ["フャ","fya"],["フュ","fyu"],["フョ","fyo"],
    ["ティ","ti"],["トゥ","tu"],["チェ","che"],["シェ","she"],["ジェ","je"],
    ["ディ","di"],["ドゥ","du"],
    ["ウィ","wi"],["ウェ","we"],["ウォ","wo"],
    ["スィ","si"],["ズィ","zi"],
    ["ツァ","tsa"],["ツィ","tsi"],["ツェ","tse"],["ツォ","tso"],
    ["テュ","tyu"],["デュ","dyu"],
    ["ヴァ","va"],["ヴィ","vi"],["ヴェ","ve"],["ヴォ","vo"],["ヴュ","vyu"],
    ["クァ","kwa"],["クィ","kwi"],["クェ","kwe"],["クォ","kwo"],
    ["グァ","gwa"],["グィ","gwi"],["グェ","gwe"],["グォ","gwo"],
  ]);

  function leadingConsonant(romaji){
    const m = romaji.match(/^(ch|sh|ky|gy|ny|hy|by|py|my|ry|ts|j|f|v|t|d|k|g|s|z|n|h|b|p|m|r|w|y)/);
    return m ? m[1] : "";
  }

  function kanaToUnits(kana){
    const units = [];
    for (let i=0;i<kana.length;i++){
      const two = kana.slice(i, i+2);
      if (KANA_MAP.has(two)) { units.push(two); i++; continue; }
      units.push(kana.slice(i, i+1));
    }
    return units;
  }

  function unitsToRomaji(units){
    let out = "";
    for (let i=0;i<units.length;i++){
      const u = units[i];
      const v = KANA_MAP.get(u);
      if (!v) continue;
      if (v === "(sokuon)"){
        const next = units[i+1];
        const nextRomaji = next ? (KANA_MAP.get(next) || "") : "";
        const c = leadingConsonant(nextRomaji);
        out += c ? c : "";
        continue;
      }
      if (v === "(long)"){
        const prev = out[out.length-1] || "";
        if ("aeiou".includes(prev)) out += prev;
        continue;
      }
      out += v;
    }
    return out;
  }

  function expandLenientEquivalents(str){
    const base = stripSpaces(clean(str));
    const set = new Set([base]);

    const swaps = [
      ["shi","si"], ["chi","ti"], ["tsu","tu"], ["fu","hu"], ["ji","zi"],
      ["ja","zya"], ["ju","zyu"], ["jo","zyo"],
      ["sha","sya"], ["shu","syu"], ["sho","syo"],
      ["cha","tya"], ["chu","tyu"], ["cho","tyo"],
    ];

    for (const [a,b] of swaps) {
      for (const v of Array.from(set)) {
        if (v.includes(a)) set.add(v.replaceAll(a,b));
        if (v.includes(b)) set.add(v.replaceAll(b,a));
      }
    }

    const patterns = [
      { std:"cha", almost:["chya","cya"] },
      { std:"chu", almost:["chyu","cyu"] },
      { std:"cho", almost:["chyo","cyo"] },
      { std:"sha", almost:["shya","sya"] },
      { std:"shu", almost:["shyu","syu"] },
      { std:"sho", almost:["shyo","syo"] },
      { std:"ja",  almost:["jya","zya"] },
      { std:"ju",  almost:["jyu","zyu"] },
      { std:"jo",  almost:["jyo","zyo"] },
    ];
    for (const p of patterns){
      for (const v of Array.from(set)){
        if (v.includes(p.std)) for (const a of p.almost) set.add(v.replaceAll(p.std, a));
        for (const a of p.almost) if (v.includes(a)) set.add(v.replaceAll(a, p.std));
      }
    }

    for (const v of Array.from(set)) {
      set.add(v.replaceAll("ou","oo"));
      set.add(v.replaceAll("oo","ou"));
      set.add(v.replaceAll("aa","a"));
      set.add(v.replaceAll("ii","i"));
      set.add(v.replaceAll("uu","u"));
      set.add(v.replaceAll("ee","e"));
      set.add(v.replaceAll("oo","o"));
    }

    return set;
  }

  function escapeHtml(s){
    return (s ?? "").toString()
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  /* --- Diff helpers (for bolding mistakes + specific Almost feedback) --- */
  function highlightUserDiffHtml(userRaw, expectedRaw){
    const u = stripSpaces(clean(userRaw));
    const e = stripSpaces(clean(expectedRaw));
    const max = Math.max(u.length, e.length);
    let html = "";
    for (let i=0;i<max;i++){
      const uc = u[i] ?? "";
      const ec = e[i] ?? "";
      const wrong = (uc !== ec);
      if (!uc) continue; // don't render extra expected chars in the user string
      html += wrong ? `<b>${escapeHtml(uc)}</b>` : escapeHtml(uc);
    }
    return html || escapeHtml(u || "—");
  }

  function highlightExpectedDiffHtml(userRaw, expectedRaw){
    const u = stripSpaces(clean(userRaw));
    const e = stripSpaces(clean(expectedRaw));
    const max = Math.max(u.length, e.length);
    let html = "";
    for (let i=0;i<max;i++){
      const uc = u[i] ?? "";
      const ec = e[i] ?? "";
      const wrong = (uc !== ec);
      if (!ec) continue;
      html += wrong ? `<b>${escapeHtml(ec)}</b>` : escapeHtml(ec);
    }
    return html || escapeHtml(e || "—");
  }

  function describeDiff(userRaw, expectedRaw){
    const u = stripSpaces(clean(userRaw));
    const e = stripSpaces(clean(expectedRaw));
    if (!u || !e) return "";

    const diffs = [];
    const max = Math.max(u.length, e.length);
    for (let i=0;i<max;i++){
      const uc = u[i] ?? "∅";
      const ec = e[i] ?? "∅";
      if (uc !== ec) diffs.push({ i, got: uc, exp: ec });
      if (diffs.length >= 6) break; // keep it readable
    }

    if (!diffs.length) return "";

    // If it looks like a single substitution or insertion/deletion, call it out explicitly
    if (diffs.length === 1){
      const d = diffs[0];
      if (d.got === "∅") return `You missed a character at position ${d.i+1}: expected “${d.exp}”.`;
      if (d.exp === "∅") return `You added an extra character at position ${d.i+1}: “${d.got}”.`;
      return `At position ${d.i+1}: expected “${d.exp}”, you typed “${d.got}”.`;
    }

    // Otherwise: summarize first few positions
    const parts = diffs.map(d => {
      if (d.got === "∅") return `pos ${d.i+1}: missing “${d.exp}”`;
      if (d.exp === "∅") return `pos ${d.i+1}: extra “${d.got}”`;
      return `pos ${d.i+1}: “${d.got}”→“${d.exp}”`;
    });
    return `Differences: ${parts.join(", ")}.`;
  }

  // wo/o helper: apply only when kana contains を/ヲ and "o" is a standalone token in the accepted romaji
  function addWoParticleVariants(acceptedList, kana){
    const accepted = Array.isArray(acceptedList) ? acceptedList.slice() : [acceptedList];
    const hasWoParticle = (kana || "").includes("を") || (kana || "").includes("ヲ");
    if (!hasWoParticle) return accepted;

    for (const a of accepted.slice()){
      const base = clean(a);
      const alt1 = base.replace(/\bo\b/g, "wo");
      const alt2 = base.replace(/\bwo\b/g, "o");
      if (alt1 !== base) accepted.push(alt1);
      if (alt2 !== base) accepted.push(alt2);
    }

    // Single-character を/ヲ: accept "wo" too
    if (kana === "を" || kana === "ヲ") accepted.push("wo");

    return Array.from(new Set(accepted));
  }

  function classifyMatch(userInput, primary, settings, itemKana){
    const user = stripSpaces(clean(userInput));
    const prim = stripSpaces(clean(primary));
    if (!user) return { verdict:"bad", reason:"No answer entered." };
    if (user === prim) return { verdict:"good" };
    if (!settings.lenient) return { verdict:"bad" };

    const primSet = new Set([prim, ...expandLenientEquivalents(prim)]);

    // Add wo/o particle variants when relevant
    if ((itemKana || "").includes("を") || (itemKana || "").includes("ヲ")) {
      const primWithSpaces = clean(primary);
      const tokenWo = stripSpaces(primWithSpaces.replace(/\bo\b/g, "wo"));
      const tokenO  = stripSpaces(primWithSpaces.replace(/\bwo\b/g, "o"));
      if (tokenWo) primSet.add(tokenWo);
      if (tokenO) primSet.add(tokenO);
      if ((itemKana === "を" || itemKana === "ヲ")) primSet.add("wo");
    }

    if (primSet.has(user)) {
      if (settings.allowAlmost) {
        // Prefer very specific “Almost” messages when we can identify the pattern
        const yReasonPairs = [
          ["cha","cya"],["cha","chya"],["chu","cyu"],["chu","chyu"],["cho","cyo"],["cho","chyo"],
          ["sha","sya"],["sha","shya"],["shu","syu"],["shu","shyu"],["sho","syo"],["sho","shyo"],
          ["ja","jya"],["ju","jyu"],["jo","jyo"],
        ];
        for (const [std, alt] of yReasonPairs){
          if (prim.includes(std) && user.includes(alt)) {
            return { verdict:"almost", reason:`You wrote “${alt}” where the standard spelling is “${std}”. ${describeDiff(userInput, primary)}`.trim() };
          }
        }

        // Topic particle は (wa vs ha)
        const swapped = prim.replaceAll("wa","ha");
        if (user === swapped) {
          return { verdict:"almost", reason:`You typed “ha” for the topic particle “は”. In romaji we usually write it as “wa”. ${describeDiff(userInput, primary)}`.trim() };
        }

        // Object particle を (o vs wo)
        if ((itemKana || "").includes("を") || (itemKana || "").includes("ヲ")) {
          const primWithSpaces = clean(primary);
          const asWo = stripSpaces(primWithSpaces.replace(/\bo\b/g, "wo"));
          const asO  = stripSpaces(primWithSpaces.replace(/\bwo\b/g, "o"));
          if (user === asWo || user === asO || ((itemKana === "を" || itemKana === "ヲ") && user === "wo")) {
            return { verdict:"almost", reason:`For the object particle “を”, “o” is the common standard (though “wo” is also seen). ${describeDiff(userInput, primary)}`.trim() };
          }
        }

        return { verdict:"almost", reason:`Close variant. ${describeDiff(userInput, primary)}`.trim() };
      }
      return { verdict:"good" };
    }
    return { verdict:"bad" };
  }

  function isCorrectDetailed(userInput, acceptedList, settings, itemKana){
    let accepted = Array.isArray(acceptedList) ? acceptedList : [acceptedList];
    accepted = addWoParticleVariants(accepted, itemKana);

    const primary = accepted[0] ?? "";
    const user = stripSpaces(clean(userInput));
    if (!user) return { verdict:"bad", primary, accepted, reason:"No answer entered." };

    const primaryNorm = stripSpaces(clean(primary));
    if (user === primaryNorm) return { verdict:"good", primary, accepted };

    // If they matched a non-primary accepted spelling, make the Almost reason very explicit
    for (let i=1;i<accepted.length;i++){
      const a = stripSpaces(clean(accepted[i]));
      if (user === a) {
        if (settings.allowAlmost) {
          return {
            verdict:"almost",
            primary,
            accepted,
            reason: `You entered an accepted alternate spelling (“${stripSpaces(clean(accepted[i]))}”), but the standard we’re aiming for is “${primaryNorm}”. ${describeDiff(userInput, primary)}`.trim()
          };
        }
        return { verdict:"good", primary, accepted };
      }
    }

    const classified = classifyMatch(userInput, primary, settings, itemKana);
    if (classified.verdict !== "bad") return { verdict: classified.verdict, primary, accepted, reason: classified.reason };
    return { verdict:"bad", primary, accepted };
  }

  /* -------- Data (same pool as before) -------- */
  const WORDS_BASE = [
    ["こんにちは","konnichiwa","Hello / good afternoon"],
    ["おはよう","ohayou","Good morning (casual)"],
    ["おはようございます","ohayou gozaimasu","Good morning (polite)"],
    ["こんばんは","konbanwa","Good evening"],
    ["ありがとう","arigatou","Thank you"],
    ["ありがとうございます","arigatou gozaimasu","Thank you (polite)"],
    ["すみません","sumimasen","Excuse me / sorry"],
    ["ごめんなさい","gomen nasai","I’m sorry"],
    ["はい","hai","Yes"],
    ["いいえ","iie","No"],
    ["だいじょうぶ","daijoubu","It’s okay / all right"],
    ["おねがいします","onegaishimasu","Please (polite request)"],
    ["ください","kudasai","Please (request)"],
    ["どうぞ","douzo","Here you go / please"],
    ["わかりました","wakarimashita","I understand"],
    ["わかりません","wakarimasen","I don’t understand"],
    ["もういちど","mou ichido","One more time"],
    ["ゆっくり","yukkuri","Slowly"],
    ["ちょっと","chotto","A bit / a moment"],
    ["いま","ima","Now"],
    ["あとで","atode","Later"],
    ["なまえ","namae","Name"],
    ["ともだち","tomodachi","Friend"],
    ["かぞく","kazoku","Family"],
    ["ひと","hito","Person"],
    ["こども","kodomo","Child"],
    ["せんせい","sensei","Teacher"],
    ["がくせい","gakusei","Student"],
    ["ほん","hon","Book"],
    ["かみ","kami","Paper"],
    ["みず","mizu","Water"],
    ["おちゃ","ocha","Tea"],
    ["ごはん","gohan","Meal / cooked rice"],
    ["ぱん","pan","Bread"],
    ["おにぎり","onigiri","Rice ball"],
    ["すし","sushi","Sushi"],
    ["てんぷら","tenpura","Tempura"],
    ["らーめん","raamen","Ramen"],
    ["うどん","udon","Udon noodles"],
    ["そば","soba","Soba noodles"],
    ["やさい","yasai","Vegetables"],
    ["くだもの","kudamono","Fruit"],
    ["にく","niku","Meat"],
    ["たまご","tamago","Egg"],
    ["おいしい","oishii","Delicious"],
    ["たのしい","tanoshii","Fun"],
    ["つかれた","tsukareta","I’m tired"],
    ["ねむい","nemui","Sleepy"],
    ["あつい","atsui","Hot"],
    ["さむい","samui","Cold"],
    ["えき","eki","Station"],
    ["でんしゃ","densha","Train"],
    ["くうこう","kuukou","Airport"],
    ["みぎ","migi","Right"],
    ["ひだり","hidari","Left"],
    ["まっすぐ","massugu","Straight ahead"],
    ["おかね","okane","Money"],
    ["いくら","ikura","How much"],
    ["ホテル","hoteru","Hotel"],
    ["レストラン","resutoran","Restaurant"],
    ["コーヒー","koohii","Coffee"],
    ["アイスクリーム","aisukuriimu","Ice cream"],
    ["タクシー","takushii","Taxi"],
    ["コンビニ","konbini","Convenience store"],
    ["チケット","chiketto","Ticket"],
    ["パスポート","pasupooto","Passport"],
    ["トイレ","toire","Toilet / restroom"],
    ["スマホ","sumaho","Smartphone"],
    ["ワイファイ","waifai","Wi-Fi"],
  ];
  const WORDS_EXTRA = [
    ["これ","kore","This"],["それ","sore","That (near you)"],["あれ","are","That (over there)"],
    ["ここ","koko","Here"],["そこ","soko","There (near you)"],["あそこ","asoko","Over there"],
    ["どこ","doko","Where"],["なに","nani","What"],["いつ","itsu","When"],["だれ","dare","Who"],
    ["きょう","kyou","Today"],["あした","ashita","Tomorrow"],["きのう","kinou","Yesterday"],
    ["げんき","genki","Well / healthy"],["いそがしい","isogashii","Busy"],["ひま","hima","Free time"],
    ["すき","suki","Like"],["きらい","kirai","Dislike"],["だいすき","daisuki","Love / really like"],
    ["かんたん","kantan","Easy / simple"],["むずかしい","muzukashii","Difficult"],["だいじ","daiji","Important"],
    ["たぶん","tabun","Maybe"],["ぜんぶ","zenbu","All / everything"],
    ["まだ","mada","Not yet"],["もう","mou","Already"],
    ["はじめまして","hajimemashite","Nice to meet you"],
    ["よろしく","yoroshiku","Nice to meet you / please be kind"],
    ["もしもし","moshimoshi","Hello (on the phone)"],
    ["あさ","asa","Morning"],["ひる","hiru","Daytime"],["よる","yoru","Night"],
    ["はる","haru","Spring"],["なつ","natsu","Summer"],["あき","aki","Autumn"],["ふゆ","fuyu","Winter"],
    ["くるま","kuruma","Car"],["じてんしゃ","jitensha","Bicycle"],
    ["ねこ","neko","Cat"],["いぬ","inu","Dog"],["とり","tori","Bird"],
    ["いえ","ie","House"],["へや","heya","Room"],["まど","mado","Window"],["とびら","tobira","Door"],
    ["かばん","kaban","Bag"],["くつ","kutsu","Shoes"],["かさ","kasa","Umbrella"],
    ["アプリ","apuri","App"],["バッテリー","batterii","Battery"],["マップ","mappu","Map"],
    ["サンドイッチ","sandoicchi","Sandwich"],["エレベーター","erebeetaa","Elevator"],
  ];

  const WORD_ITEMS = [...WORDS_BASE, ...WORDS_EXTRA].map(([kana, romaji, meaning]) => ({
    type:"word", kana, accepted:[romaji], meaning, script: /[ァ-ヶー]/.test(kana) ? "kata" : "hira"
  }));

  const SENT_ITEMS = [
    ["なまえはなんですか","namae wa nan desu ka","What is your name?"],
    ["わたしはがくせいです","watashi wa gakusei desu","I am a student."],
    ["すみません、えきはどこですか","sumimasen eki wa doko desu ka","Excuse me, where is the station?"],
    ["これください","kore kudasai","This, please."],
    ["みずをください","mizu o kudasai","Water, please."],
    ["ここでたべます","koko de tabemasu","I’ll eat here."],
    ["もちかえりです","mochikaeri desu","It’s takeaway."],
    ["いくらですか","ikura desu ka","How much is it?"],
    ["だいじょうぶです","daijoubu desu","It’s okay."],
    ["おいしいです","oishii desu","It’s delicious."],
    ["もういちどいってください","mou ichido itte kudasai","Please say it one more time."],
    ["ゆっくりはなしてください","yukkuri hanashite kudasai","Please speak slowly."],
    ["まっすぐいってください","massugu itte kudasai","Please go straight."],
    ["みぎにまがってください","migi ni magatte kudasai","Please turn right."],
    ["ひだりにまがってください","hidari ni magatte kudasai","Please turn left."],
    ["トイレはどこですか","toire wa doko desu ka","Where is the toilet?"],
    ["ホテルはどこですか","hoteru wa doko desu ka","Where is the hotel?"],
    ["コーヒーをください","koohii o kudasai","Coffee, please."],
    ["コンビニはどこですか","konbini wa doko desu ka","Where is the convenience store?"],
    ["タクシーをよんでください","takushii o yonde kudasai","Please call a taxi."],
  ].map(([kana, romaji, meaning]) => ({
    type:"sentence", kana, accepted:[romaji], meaning, script: /[ァ-ヶー]/.test(kana) ? "kata" : "hira"
  }));

  function buildCharItems(script, difficulty){
    const items = [];
    const isHira = (s) => /[ぁ-ゖゔ]/.test(s);
    const isKata = (s) => /[ァ-ヶヴー]/.test(s);

    for (const [kana, romaji] of KANA_MAP.entries()){
      if (romaji === "(sokuon)" || romaji === "(long)") continue;

      const isTwo = kana.length === 2;
      const extended = ["ティ","トゥ","ディ","ドゥ","チェ","シェ","ジェ","ファ","フィ","フェ","フォ","フャ","フュ","フョ",
                        "ウィ","ウェ","ウォ","ツァ","ツィ","ツェ","ツォ","クァ","クィ","クェ","クォ","グァ","グィ","グェ","グォ",
                        "ゔぁ","ゔぃ","ゔぇ","ゔぉ","ゔゅ","ヴァ","ヴィ","ヴェ","ヴォ","ヴュ","ふぁ","ふぃ","ふぇ","ふぉ",
                        "てゃ","てゅ","てょ","でゃ","でゅ","でょ"].includes(kana);

      if (script === "hira" && !isHira(kana)) continue;
      if (script === "kata" && !isKata(kana)) continue;

      if (difficulty === "easy"){
        if (isTwo) continue;
        if (["ぁ","ぃ","ぅ","ぇ","ぉ","ゃ","ゅ","ょ","っ","ゎ","ァ","ィ","ゥ","ェ","ォ","ャ","ュ","ョ","ッ","ヮ"].includes(kana)) continue;
        if (extended) continue;
      } else if (difficulty === "standard"){
        if (extended) continue;
      }

      items.push({
        type:"char",
        kana,
        accepted:[romaji],
        meaning: (isHira(kana) ? "Hiragana character" : "Katakana character"),
        script: isHira(kana) ? "hira" : "kata"
      });
    }
    return items;
  }

  function buildItems(settings){
    const { mixChars, mixWords, mixSentences, script, difficulty } = settings;
    const items = [];
    if (mixChars) items.push(...buildCharItems(script, difficulty));

    if (mixWords){
      for (const w of WORD_ITEMS){
        if (script === "hira" && w.script === "kata") continue;
        if (script === "kata" && w.script === "hira") continue;
        items.push(w);
      }
    }

    if (mixSentences){
      for (const s of SENT_ITEMS){
        if (script === "hira" && /[ァ-ヶー]/.test(s.kana)) continue;
        if (script === "kata" && /[ぁ-ゖゔ]/.test(s.kana)) continue;
        items.push(s);
      }
    }

    return items.length ? items : buildCharItems(script, difficulty);
  }

  function shuffle(arr){
    const a = arr.slice();
    for (let i=a.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i],a[j]]=[a[j],a[i]];
    }
    return a;
  }

  function loadJson(key, fallback){
    try{
      const raw = localStorage.getItem(key);
      if (!raw) return fallback;
      return JSON.parse(raw) ?? fallback;
    }catch{ return fallback; }
  }
  function saveJson(key, value){
    try{ localStorage.setItem(key, JSON.stringify(value)); }catch{}
  }

  function unitKey(unit){
    const script = /[ぁ-ゖゔ]/.test(unit) ? "hira" : (/[ァ-ヶヴー]/.test(unit) ? "kata" : "other");
    return `${script}|${unit}`;
  }
  function ensureUnitStat(stats, key){
    if (!stats[key]) stats[key] = { seen:0, wrong:0, last:0 };
    return stats[key];
  }
  function troubleScoreUnit(stat){
    const seen = stat?.seen || 0;
    const wrong = stat?.wrong || 0;
    if (seen < 4 && wrong < 2) return 0;
    const rate = wrong / Math.max(1, seen);
    const volumeBoost = Math.min(1, seen / 12);
    return rate * (0.65 + 0.35 * volumeBoost);
  }
  function getTroubleUnitKeysFromPool(poolUnits, unitStats){
    const out = [];
    for (const u of poolUnits){
      const key = unitKey(u);
      const stat = unitStats[key];
      const score = troubleScoreUnit(stat);
      if (score > 0) out.push({ unit:u, score, seen:stat.seen, wrong:stat.wrong });
    }
    out.sort((a,b) => b.score - a.score || b.wrong - a.wrong || b.seen - a.seen);
    return out;
  }

  function attributeUnits(itemKana, userRomajiRaw){
    const units = kanaToUnits(itemKana);
    const expectedPerUnit = [];
    for (let i=0;i<units.length;i++){
      const u = units[i];
      const v = KANA_MAP.get(u);
      if (!v) { expectedPerUnit.push(""); continue; }
      if (v === "(sokuon)"){
        const next = units[i+1];
        const nextRomaji = next ? (KANA_MAP.get(next) || "") : "";
        expectedPerUnit.push(leadingConsonant(nextRomaji) || "");
        continue;
      }
      if (v === "(long)"){ expectedPerUnit.push("(long)"); continue; }
      expectedPerUnit.push(v);
    }

    const user = stripSpaces(clean(userRomajiRaw));
    let cursor = 0;
    const wrongUnits = new Set();
    const seenUnits = new Set();

    const unitVariants = expectedPerUnit.map(v => {
      if (v === "(long)" || !v) return new Set([""]);
      return expandLenientEquivalents(v);
    });

    for (let i=0;i<units.length;i++){
      const u = units[i];
      const v = expectedPerUnit[i];
      if (v === "(long)" || !v) continue;

      seenUnits.add(u);

      const candidates = Array.from(unitVariants[i]).sort((a,b)=>b.length-a.length);
      let matched = null;
      for (const c of candidates){
        if (!c) continue;
        if (user.slice(cursor, cursor+c.length) === c) { matched = c; break; }
      }
      if (matched) cursor += matched.length;
      else {
        wrongUnits.add(u);
        if (cursor < user.length) cursor += 1;
      }
    }

    const filterKana = (x) => KANA_MAP.has(x) && KANA_MAP.get(x) !== "(sokuon)" && KANA_MAP.get(x) !== "(long)";
    return {
      seen: Array.from(seenUnits).filter(filterKana),
      wrong: Array.from(wrongUnits).filter(filterKana),
    };
  }

  const els = {
    prompt: document.getElementById("prompt"),
    answer: document.getElementById("answer"),
    result: document.getElementById("result"),
    checkBtn: document.getElementById("checkBtn"),
    revealBtn: document.getElementById("revealBtn"),
    nextBtn: document.getElementById("nextBtn"),

    typeMeta: document.getElementById("typeMeta"),
    indexMeta: document.getElementById("indexMeta"),

    streakValue: document.getElementById("streakValue"),
    accValue: document.getElementById("accValue"),
    troubleValue: document.getElementById("troubleValue"),
    modeTiny: document.getElementById("modeTiny"),
    seenTiny: document.getElementById("seenTiny"),

    poolPill: document.getElementById("poolPill"),
    scriptPill: document.getElementById("scriptPill"),
    difficultyPill: document.getElementById("difficultyPill"),

    menuBtn: document.getElementById("menuBtn"),
    drawer: document.getElementById("drawer"),
    drawerOverlay: document.getElementById("drawerOverlay"),
    closeDrawerBtn: document.getElementById("closeDrawerBtn"),

    helpBtn: document.getElementById("helpBtn"),
    helpOverlay: document.getElementById("helpOverlay"),
    helpModal: document.getElementById("helpModal"),
    closeHelpBtn: document.getElementById("closeHelpBtn"),
    dontShowAgainBtn: document.getElementById("dontShowAgainBtn"),

    modeSelect: document.getElementById("modeSelect"),
    modeHint: document.getElementById("modeHint"),
    resetSessionBtn: document.getElementById("resetSessionBtn"),
    resetHistoryBtn: document.getElementById("resetHistoryBtn"),

    mixChars: document.getElementById("mixChars"),
    mixWords: document.getElementById("mixWords"),
    mixSentences: document.getElementById("mixSentences"),
    allowLenient: document.getElementById("allowLenient"),
    allowAlmost: document.getElementById("allowAlmost"),
    scriptSelect: document.getElementById("scriptSelect"),
    difficultySelect: document.getElementById("difficultySelect"),
  };

  const state = {
    settings: null,
    mode: "normal",
    pool: [],
    deck: [],
    idx: 0,
    current: null,

    checked: false,
    stats: { correct:0, wrong:0, almost:0, seen:0, streak:0 },

    unitStats: loadJson(LS_KEY_UNIT_STATS, {}),
    recentUnits: loadJson(LS_KEY_RECENT_UNITS, []),
  };

  function getSettings(){
    return {
      mixChars: els.mixChars.checked,
      mixWords: els.mixWords.checked,
      mixSentences: els.mixSentences.checked,
      lenient: els.allowLenient.checked,
      allowAlmost: els.allowAlmost.checked,
      script: els.scriptSelect.value,
      difficulty: els.difficultySelect.value,
    };
  }

  function setPills(){
    const s = state.settings;
    const what = [];
    if (s.mixChars) what.push("chars");
    if (s.mixWords) what.push("words");
    if (s.mixSentences) what.push("sentences");
    els.poolPill.textContent = `Practice: ${what.join(" + ") || "chars"}`;
    els.scriptPill.textContent = `Script: ${s.script === "both" ? "hiragana + katakana" : s.script}`;
    els.difficultyPill.textContent = `Level: ${s.difficulty}`;
  }

  function countTroubleKana(){
    const eligibleUnits = buildCharItems(state.settings.script, "spicy").map(x => x.kana);
    return getTroubleUnitKeysFromPool(eligibleUnits, state.unitStats).length;
  }

  function updateStatsUI(){
    const { correct, almost, seen, streak } = state.stats;
    const acc = seen ? Math.round(((correct + 0.5*almost)/seen)*100) : null;

    els.streakValue.textContent = String(streak);
    els.accValue.textContent = acc === null ? "—" : `${acc}%`;
    els.seenTiny.textContent = `${seen} attempts`;
    els.troubleValue.textContent = String(countTroubleKana());

    const modeLabel = state.mode === "normal" ? "Normal" : (state.mode === "trouble" ? "Trouble kana" : "Recent kana");
    els.modeTiny.textContent = `Mode: ${modeLabel}`;
  }

  function buildPool(){
    state.settings = getSettings();
    setPills();
    state.pool = buildItems(state.settings);
  }

  function applyMode(resetIndex){
    state.mode = els.modeSelect.value;

    if (state.mode === "normal"){
      state.deck = shuffle(state.pool);
      els.modeHint.textContent = "A mix of what you’ve enabled in settings.";
    } else if (state.mode === "trouble"){
      const allUnits = buildCharItems(state.settings.script, "spicy").map(x => x.kana);
      const trouble = getTroubleUnitKeysFromPool(allUnits, state.unitStats);
      let deckUnits = trouble.slice(0, 60).map(t => t.unit);

      if (deckUnits.length < 12){
        deckUnits = shuffle(allUnits).slice(0, 30);
        els.modeHint.textContent = "Not enough trouble data yet — showing random kana to build your profile.";
      } else {
        els.modeHint.textContent = `Drilling your most-missed kana (${deckUnits.length} in this deck).`;
      }

      state.deck = shuffle(deckUnits.map(u => ({
        type:"char",
        kana: u,
        accepted: [KANA_MAP.get(u)],
        meaning: /[ぁ-ゖゔ]/.test(u) ? "Hiragana character" : "Katakana character",
        script: /[ぁ-ゖゔ]/.test(u) ? "hira" : "kata",
      })));
    } else {
      const allowed = (u) => {
        if (state.settings.script === "both") return true;
        if (state.settings.script === "hira") return /[ぁ-ゖゔ]/.test(u);
        if (state.settings.script === "kata") return /[ァ-ヶヴー]/.test(u);
        return true;
      };
      let deckUnits = state.recentUnits.filter(allowed).slice(0, 60);
      if (deckUnits.length < 10){
        const allUnits = buildCharItems(state.settings.script, "spicy").map(x => x.kana);
        deckUnits = shuffle(allUnits).slice(0, 30);
        els.modeHint.textContent = "No recent trouble kana yet — showing random kana for quick practice.";
      } else {
        els.modeHint.textContent = `Redoing your last ${deckUnits.length} missed kana.`;
      }
      state.deck = shuffle(deckUnits.map(u => ({
        type:"char",
        kana: u,
        accepted: [KANA_MAP.get(u)],
        meaning: /[ぁ-ゖゔ]/.test(u) ? "Hiragana character" : "Katakana character",
        script: /[ぁ-ゖゔ]/.test(u) ? "hira" : "kata",
      })));
    }

    if (resetIndex) state.idx = 0;
    state.current = null;
    state.checked = false;

    nextItem(true);
    updateStatsUI();
  }

  function rebuildPool(){
    buildPool();
    applyMode(true);
  }

  function nextItem(isFirst=false){
    state.checked = false;

    if (state.deck.length === 0){
      state.deck = shuffle(state.pool.length ? state.pool : buildItems(state.settings));
      state.idx = 0;
    }
    if (state.idx >= state.deck.length){
      state.deck = shuffle(state.deck);
      state.idx = 0;
    }

    state.current = state.deck[state.idx++];
    els.prompt.textContent = state.current.kana;
    els.answer.value = "";
    els.answer.focus();

    els.typeMeta.textContent = `Type: ${state.current.type}`;
    els.indexMeta.textContent = `Card ${state.idx} / ${state.deck.length}`;

    els.result.innerHTML = isFirst
      ? `<p class="mini">Press <b>Enter</b> to check. Press <b>Enter</b> again for next.</p>`
      : `<p class="mini">New card. <b>Enter</b> to check.</p>`;
  }

  function showResult({ status, title, meaning, romaji, noteHtml }){
    const meaningText = meaning && meaning.trim()
      ? meaning
      : (state.current?.type === "char"
          ? (state.current?.meaning || "Kana character")
          : "—");

    const def = `
      <div class="defBox">
        <p class="defLabel">Meaning</p>
        <p class="defText">${escapeHtml(meaningText)}</p>
      </div>`;

    const r = romaji ? `<p class="mini"><b>Romaji:</b> <span class="mono">${escapeHtml(romaji)}</span></p>` : "";
    els.result.innerHTML = `
      <p class="status ${status}">${title}</p>
      ${def}
      ${r}
      ${noteHtml || ""}
    `;
  }

  function addRecentUnit(unit){
    state.recentUnits = state.recentUnits.filter(x => x !== unit);
    state.recentUnits.unshift(unit);
    if (state.recentUnits.length > 120) state.recentUnits = state.recentUnits.slice(0,120);
    saveJson(LS_KEY_RECENT_UNITS, state.recentUnits);
  }

  function updateUnitStatsFromAttempt(item, userInput, verdict){
    const { seen, wrong } = attributeUnits(item.kana, userInput);

    for (const u of seen){
      const key = unitKey(u);
      const st = ensureUnitStat(state.unitStats, key);
      st.seen += 1;
      st.last = Date.now();
    }

    if (verdict === "bad"){
      for (const u of wrong){
        const key = unitKey(u);
        const st = ensureUnitStat(state.unitStats, key);
        st.wrong += 1;
        st.last = Date.now();
        addRecentUnit(u);
      }
    }

    saveJson(LS_KEY_UNIT_STATS, state.unitStats);
  }

  function checkAnswer(){
    if (!state.current || state.checked) return;

    const item = state.current;
    const userRaw = els.answer.value;

    const primary = (item.accepted && item.accepted[0])
      ? item.accepted[0]
      : unitsToRomaji(kanaToUnits(item.kana));

    const accepted = [primary, primary.replaceAll("wa","ha")];
    const result = isCorrectDetailed(userRaw, accepted, state.settings, item.kana);

    state.stats.seen += 1;

    const userNorm = stripSpaces(clean(userRaw));
    const primaryNorm = stripSpaces(clean(primary));

    if (result.verdict === "good"){
      state.stats.correct += 1;
      state.stats.streak += 1;
      updateUnitStatsFromAttempt(item, userRaw, "good");

      showResult({
        status: "good",
        title: "Correct ✅",
        meaning: item.meaning || "",
        romaji: primary
      });
    } else if (result.verdict === "almost"){
      state.stats.almost += 1;
      state.stats.streak += 1;
      updateUnitStatsFromAttempt(item, userRaw, "almost");

      const yourHtml = highlightUserDiffHtml(userRaw, primary);
      const expHtml = highlightExpectedDiffHtml(userRaw, primary);

      showResult({
        status: "almost",
        title: "Almost ✅",
        meaning: item.meaning || "",
        romaji: primary,
        noteHtml: `
          <p class="mini"><b>Your answer (normalized):</b> <span class="mono">${yourHtml || escapeHtml(userNorm || "—")}</span></p>
          <p class="mini"><b>Expected:</b> <span class="mono">${expHtml || escapeHtml(primaryNorm)}</span></p>
          <p class="mini">${escapeHtml(result.reason || describeDiff(userRaw, primary) || "Close variant.")}</p>
        `
      });
    } else {
      state.stats.wrong += 1;
      state.stats.streak = 0;
      updateUnitStatsFromAttempt(item, userRaw, "bad");

      const yourHtml = highlightUserDiffHtml(userRaw, primary);

      showResult({
        status: "bad",
        title: result.reason === "No answer entered." ? "No answer ❗" : "Incorrect ❌",
        meaning: item.meaning || "",
        romaji: primary,
        noteHtml: `
          <p class="mini"><b>Your answer (normalized):</b> <span class="mono">${yourHtml || escapeHtml(userNorm || "—")}</span></p>
          <p class="mini">${escapeHtml(describeDiff(userRaw, primary) || "")}</p>
        `
      });
    }

    state.checked = true;
    updateStatsUI();
  }

  function reveal(){
    if (!state.current) return;
    const item = state.current;
    const primary = (item.accepted && item.accepted[0])
      ? item.accepted[0]
      : unitsToRomaji(kanaToUnits(item.kana));

    showResult({
      status: "almost",
      title: "Revealed 👀",
      meaning: item.meaning || "",
      romaji: primary
    });
    state.checked = true;
  }

  function next(){ nextItem(false); }

  function resetSession(){
    state.stats = { correct:0, wrong:0, almost:0, seen:0, streak:0 };
    updateStatsUI();
    els.result.innerHTML = `<p class="mini">Session stats reset.</p>`;
  }

  function resetHistory(){
    state.unitStats = {};
    state.recentUnits = [];
    saveJson(LS_KEY_UNIT_STATS, state.unitStats);
    saveJson(LS_KEY_RECENT_UNITS, state.recentUnits);
    updateStatsUI();
    els.modeHint.textContent = "Learning history cleared. Trouble kana will repopulate as you practise.";
  }

  function openDrawer(){
    els.drawer.classList.add("open");
    els.drawerOverlay.classList.add("open");
    document.body.style.overflow = "hidden";
  }
  function closeDrawer(){
    els.drawer.classList.remove("open");
    els.drawerOverlay.classList.remove("open");
    document.body.style.overflow = "";
    els.answer.focus();
  }
  function openHelp(){
    els.helpModal.classList.add("open");
    els.helpOverlay.classList.add("open");
    document.body.style.overflow = "hidden";
  }
  function closeHelp(){
    els.helpModal.classList.remove("open");
    els.helpOverlay.classList.remove("open");
    document.body.style.overflow = "";
    els.answer.focus();
  }

  els.checkBtn.addEventListener("click", checkAnswer);
  els.revealBtn.addEventListener("click", reveal);
  els.nextBtn.addEventListener("click", next);

  els.menuBtn.addEventListener("click", openDrawer);
  els.closeDrawerBtn.addEventListener("click", closeDrawer);
  els.drawerOverlay.addEventListener("click", closeDrawer);

  els.helpBtn.addEventListener("click", openHelp);
  els.closeHelpBtn.addEventListener("click", closeHelp);
  els.helpOverlay.addEventListener("click", closeHelp);

  els.dontShowAgainBtn.addEventListener("click", () => {
    saveJson(LS_KEY_TUTORIAL, true);
    closeHelp();
  });

  els.modeSelect.addEventListener("change", () => applyMode(true));

  [els.mixChars, els.mixWords, els.mixSentences, els.allowLenient, els.allowAlmost, els.scriptSelect, els.difficultySelect]
    .forEach(el => el.addEventListener("change", rebuildPool));

  els.resetSessionBtn.addEventListener("click", resetSession);
  els.resetHistoryBtn.addEventListener("click", resetHistory);

  function handleKey(e){
    const drawerOpen = els.drawer.classList.contains("open");
    const helpOpen = els.helpModal.classList.contains("open");
    if (drawerOpen || helpOpen) {
      if (e.key === "Escape") {
        if (helpOpen) closeHelp();
        else closeDrawer();
        e.preventDefault();
      }
      return;
    }
    if (e.key === "Escape") { next(); e.preventDefault(); return; }
    if (e.key === "Enter" && e.shiftKey) { reveal(); e.preventDefault(); return; }
    if (e.key === "Enter") {
      if (state.checked) next();
      else checkAnswer();
      e.preventDefault();
    }
  }

  els.answer.addEventListener("keydown", handleKey);
  document.addEventListener("keydown", (e) => {
    const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : "";
    const inInput = tag === "input" || tag === "textarea" || tag === "select" || e.target?.isContentEditable;
    if (inInput) return;
    handleKey(e);
  });

  function setInitialPills(){
    buildPool();
    applyMode(true);
    updateStatsUI();
  }

  setInitialPills();

  const tutorialSeen = !!loadJson(LS_KEY_TUTORIAL, false);
  if (!tutorialSeen) openHelp();
})();
</script>
</body>
</html>